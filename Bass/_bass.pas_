{
  BASS 2.4 Delphi unit
  Copyright (c) 1999-2008 Un4seen Developments Ltd.

  See the BASS.CHM file for more detailed documentation

  How to install
  --------------
  Copy BASS.PAS to the \LIB subdirectory of your Delphi path or your project dir
}

unit Bass;

interface

uses
  Windows, Dialogs;

const
  BASSVERSION = $204;             // API version
  BASSVERSIONTEXT = '2.4';

  // Use these to test for error from functions that return a DWORD or QWORD
  DW_ERROR = Cardinal(-1); // -1 (DWORD)
  QW_ERROR = Int64(-1);    // -1 (QWORD)

  // Error codes returned by BASS_ErrorGetCode()
  BASS_OK                 = 0;    // all is OK
  BASS_ERROR_MEM          = 1;    // memory error
  BASS_ERROR_FILEOPEN     = 2;    // can't open the file
  BASS_ERROR_DRIVER       = 3;    // can't find a free sound driver
  BASS_ERROR_BUFLOST      = 4;    // the sample buffer was lost
  BASS_ERROR_HANDLE       = 5;    // invalid handle
  BASS_ERROR_FORMAT       = 6;    // unsupported sample format
  BASS_ERROR_POSITION     = 7;    // invalid position
  BASS_ERROR_INIT         = 8;    // BASS_Init has not been successfully called
  BASS_ERROR_START        = 9;    // BASS_Start has not been successfully called
  BASS_ERROR_ALREADY      = 14;   // already initialized/paused/whatever
  BASS_ERROR_NOCHAN       = 18;   // can't get a free channel
  BASS_ERROR_ILLTYPE      = 19;   // an illegal type was specified
  BASS_ERROR_ILLPARAM     = 20;   // an illegal parameter was specified
  BASS_ERROR_NO3D         = 21;   // no 3D support
  BASS_ERROR_NOEAX        = 22;   // no EAX support
  BASS_ERROR_DEVICE       = 23;   // illegal device number
  BASS_ERROR_NOPLAY       = 24;   // not playing
  BASS_ERROR_FREQ         = 25;   // illegal sample rate
  BASS_ERROR_NOTFILE      = 27;   // the stream is not a file stream
  BASS_ERROR_NOHW         = 29;   // no hardware voices available
  BASS_ERROR_EMPTY        = 31;   // the MOD music has no sequence data
  BASS_ERROR_NONET        = 32;   // no internet connection could be opened
  BASS_ERROR_CREATE       = 33;   // couldn't create the file
  BASS_ERROR_NOFX         = 34;   // effects are not enabled
  BASS_ERROR_NOTAVAIL     = 37;   // requested data is not available
  BASS_ERROR_DECODE       = 38;   // the channel is a "decoding channel"
  BASS_ERROR_DX           = 39;   // a sufficient DirectX version is not installed
  BASS_ERROR_TIMEOUT      = 40;   // connection timedout
  BASS_ERROR_FILEFORM     = 41;   // unsupported file format
  BASS_ERROR_SPEAKER      = 42;   // unavailable speaker
  BASS_ERROR_VERSION      = 43;   // invalid BASS version (used by add-ons)
  BASS_ERROR_CODEC        = 44;   // codec is not available/supported
  BASS_ERROR_ENDED        = 45;   // the channel/file has ended
  BASS_ERROR_UNKNOWN      = -1;   // some other mystery problem

  // BASS_SetConfig options
  BASS_CONFIG_BUFFER        = 0;
  BASS_CONFIG_UPDATEPERIOD  = 1;
  BASS_CONFIG_GVOL_SAMPLE   = 4;
  BASS_CONFIG_GVOL_STREAM   = 5;
  BASS_CONFIG_GVOL_MUSIC    = 6;
  BASS_CONFIG_CURVE_VOL     = 7;
  BASS_CONFIG_CURVE_PAN     = 8;
  BASS_CONFIG_FLOATDSP      = 9;
  BASS_CONFIG_3DALGORITHM   = 10;
  BASS_CONFIG_NET_TIMEOUT   = 11;
  BASS_CONFIG_NET_BUFFER    = 12;
  BASS_CONFIG_PAUSE_NOPLAY  = 13;
  BASS_CONFIG_NET_PREBUF    = 15;
  BASS_CONFIG_NET_PASSIVE   = 18;
  BASS_CONFIG_REC_BUFFER    = 19;
  BASS_CONFIG_NET_PLAYLIST  = 21;
  BASS_CONFIG_MUSIC_VIRTUAL = 22;
  BASS_CONFIG_VERIFY        = 23;
  BASS_CONFIG_UPDATETHREADS = 24;

  // BASS_SetConfigPtr options
  BASS_CONFIG_NET_AGENT     = 16;
  BASS_CONFIG_NET_PROXY     = 17;

  // Initialization flags
  BASS_DEVICE_8BITS       = 1;    // use 8 bit resolution, else 16 bit
  BASS_DEVICE_MONO        = 2;    // use mono, else stereo
  BASS_DEVICE_3D          = 4;    // enable 3D functionality
  BASS_DEVICE_LATENCY     = 256;  // calculate device latency (BASS_INFO struct)
  BASS_DEVICE_CPSPEAKERS  = 1024; // detect speakers via Windows control panel
  BASS_DEVICE_SPEAKERS    = 2048; // force enabling of speaker assignment
  BASS_DEVICE_NOSPEAKER   = 4096; // ignore speaker arrangement

  // DirectSound interfaces (for use with BASS_GetDSoundObject)
  BASS_OBJECT_DS          = 1;   // IDirectSound
  BASS_OBJECT_DS3DL       = 2;   // IDirectSound3DListener

  // BASS_DEVICEINFO flags
  BASS_DEVICE_ENABLED     = 1;
  BASS_DEVICE_DEFAULT     = 2;
  BASS_DEVICE_INIT        = 4;

  // BASS_INFO flags (from DSOUND.H)
  DSCAPS_CONTINUOUSRATE   = $00000010;     // supports all sample rates between min/maxrate
  DSCAPS_EMULDRIVER       = $00000020;     // device does NOT have hardware DirectSound support
  DSCAPS_CERTIFIED        = $00000040;     // device driver has been certified by Microsoft
  DSCAPS_SECONDARYMONO    = $00000100;     // mono
  DSCAPS_SECONDARYSTEREO  = $00000200;     // stereo
  DSCAPS_SECONDARY8BIT    = $00000400;     // 8 bit
  DSCAPS_SECONDARY16BIT   = $00000800;     // 16 bit

  // BASS_RECORDINFO flags (from DSOUND.H)
  DSCCAPS_EMULDRIVER = DSCAPS_EMULDRIVER;  // device does NOT have hardware DirectSound recording support
  DSCCAPS_CERTIFIED = DSCAPS_CERTIFIED;    // device driver has been certified by Microsoft

  // defines for formats field of BASS_RECORDINFO (from MMSYSTEM.H)
  WAVE_FORMAT_1M08       = $00000001;      // 11.025 kHz, Mono,   8-bit
  WAVE_FORMAT_1S08       = $00000002;      // 11.025 kHz, Stereo, 8-bit
  WAVE_FORMAT_1M16       = $00000004;      // 11.025 kHz, Mono,   16-bit
  WAVE_FORMAT_1S16       = $00000008;      // 11.025 kHz, Stereo, 16-bit
  WAVE_FORMAT_2M08       = $00000010;      // 22.05  kHz, Mono,   8-bit
  WAVE_FORMAT_2S08       = $00000020;      // 22.05  kHz, Stereo, 8-bit
  WAVE_FORMAT_2M16       = $00000040;      // 22.05  kHz, Mono,   16-bit
  WAVE_FORMAT_2S16       = $00000080;      // 22.05  kHz, Stereo, 16-bit
  WAVE_FORMAT_4M08       = $00000100;      // 44.1   kHz, Mono,   8-bit
  WAVE_FORMAT_4S08       = $00000200;      // 44.1   kHz, Stereo, 8-bit
  WAVE_FORMAT_4M16       = $00000400;      // 44.1   kHz, Mono,   16-bit
  WAVE_FORMAT_4S16       = $00000800;      // 44.1   kHz, Stereo, 16-bit

  BASS_SAMPLE_8BITS       = 1;   // 8 bit
  BASS_SAMPLE_FLOAT       = 256; // 32-bit floating-point
  BASS_SAMPLE_MONO        = 2;   // mono
  BASS_SAMPLE_LOOP        = 4;   // looped
  BASS_SAMPLE_3D          = 8;   // 3D functionality
  BASS_SAMPLE_SOFTWARE    = 16;  // not using hardware mixing
  BASS_SAMPLE_MUTEMAX     = 32;  // mute at max distance (3D only)
  BASS_SAMPLE_VAM         = 64;  // DX7 voice allocation & management
  BASS_SAMPLE_FX          = 128; // old implementation of DX8 effects
  BASS_SAMPLE_OVER_VOL    = $10000; // override lowest volume
  BASS_SAMPLE_OVER_POS    = $20000; // override longest playing
  BASS_SAMPLE_OVER_DIST   = $30000; // override furthest from listener (3D only)

  BASS_STREAM_PRESCAN     = $20000; // enable pin-point seeking/length (MP3/MP2/MP1)
  BASS_MP3_SETPOS         = BASS_STREAM_PRESCAN;
  BASS_STREAM_AUTOFREE	  = $40000; // automatically free the stream when it stop/ends
  BASS_STREAM_RESTRATE	  = $80000; // restrict the download rate of internet file streams
  BASS_STREAM_BLOCK       = $100000;// download/play internet file stream in small blocks
  BASS_STREAM_DECODE      = $200000;// don't play the stream, only decode (BASS_ChannelGetData)
  BASS_STREAM_STATUS      = $800000;// give server status info (HTTP/ICY tags) in DOWNLOADPROC

  BASS_MUSIC_FLOAT        = BASS_SAMPLE_FLOAT;
  BASS_MUSIC_MONO         = BASS_SAMPLE_MONO;
  BASS_MUSIC_LOOP         = BASS_SAMPLE_LOOP;
  BASS_MUSIC_3D           = BASS_SAMPLE_3D;
  BASS_MUSIC_FX           = BASS_SAMPLE_FX;
  BASS_MUSIC_AUTOFREE     = BASS_STREAM_AUTOFREE;
  BASS_MUSIC_DECODE       = BASS_STREAM_DECODE;
  BASS_MUSIC_PRESCAN      = BASS_STREAM_PRESCAN; // calculate playback length
  BASS_MUSIC_CALCLEN      = BASS_MUSIC_PRESCAN;
  BASS_MUSIC_RAMP         = $200;  // normal ramping
  BASS_MUSIC_RAMPS        = $400;  // sensitive ramping
  BASS_MUSIC_SURROUND     = $800;  // surround sound
  BASS_MUSIC_SURROUND2    = $1000; // surround sound (mode 2)
  BASS_MUSIC_FT2MOD       = $2000; // play .MOD as FastTracker 2 does
  BASS_MUSIC_PT1MOD       = $4000; // play .MOD as ProTracker 1 does
  BASS_MUSIC_NONINTER     = $10000; // non-interpolated sample mixing
  BASS_MUSIC_SINCINTER    = $800000; // sinc interpolated sample mixing
  BASS_MUSIC_POSRESET     = $8000; // stop all notes when moving position
  BASS_MUSIC_POSRESETEX   = $400000; // stop all notes and reset bmp/etc when moving position
  BASS_MUSIC_STOPBACK     = $80000; // stop the music on a backwards jump effect
  BASS_MUSIC_NOSAMPLE     = $100000; // don't load the samples

  // Speaker assignment flags
  BASS_SPEAKER_FRONT      = $1000000;  // front speakers
  BASS_SPEAKER_REAR       = $2000000;  // rear/side speakers
  BASS_SPEAKER_CENLFE     = $3000000;  // center & LFE speakers (5.1)
  BASS_SPEAKER_REAR2      = $4000000;  // rear center speakers (7.1)
  BASS_SPEAKER_LEFT       = $10000000; // modifier: left
  BASS_SPEAKER_RIGHT      = $20000000; // modifier: right
  BASS_SPEAKER_FRONTLEFT  = BASS_SPEAKER_FRONT or BASS_SPEAKER_LEFT;
  BASS_SPEAKER_FRONTRIGHT = BASS_SPEAKER_FRONT or BASS_SPEAKER_RIGHT;
  BASS_SPEAKER_REARLEFT   = BASS_SPEAKER_REAR or BASS_SPEAKER_LEFT;
  BASS_SPEAKER_REARRIGHT  = BASS_SPEAKER_REAR or BASS_SPEAKER_RIGHT;
  BASS_SPEAKER_CENTER     = BASS_SPEAKER_CENLFE or BASS_SPEAKER_LEFT;
  BASS_SPEAKER_LFE        = BASS_SPEAKER_CENLFE or BASS_SPEAKER_RIGHT;
  BASS_SPEAKER_REAR2LEFT  = BASS_SPEAKER_REAR2 or BASS_SPEAKER_LEFT;
  BASS_SPEAKER_REAR2RIGHT = BASS_SPEAKER_REAR2 or BASS_SPEAKER_RIGHT;

  BASS_UNICODE            = $80000000;

  BASS_RECORD_PAUSE       = $8000; // start recording paused

  // DX7 voice allocation & management flags
  BASS_VAM_HARDWARE       = 1;
  BASS_VAM_SOFTWARE       = 2;
  BASS_VAM_TERM_TIME      = 4;
  BASS_VAM_TERM_DIST      = 8;
  BASS_VAM_TERM_PRIO      = 16;

  // BASS_CHANNELINFO types
  BASS_CTYPE_SAMPLE       = 1;
  BASS_CTYPE_RECORD       = 2;
  BASS_CTYPE_STREAM       = $10000;
  BASS_CTYPE_STREAM_OGG   = $10002;
  BASS_CTYPE_STREAM_MP1   = $10003;
  BASS_CTYPE_STREAM_MP2   = $10004;
  BASS_CTYPE_STREAM_MP3   = $10005;
  BASS_CTYPE_STREAM_AIFF  = $10006;
  BASS_CTYPE_STREAM_WAV   = $40000; // WAVE flag, LOWORD=codec
  BASS_CTYPE_STREAM_WAV_PCM = $50001;
  BASS_CTYPE_STREAM_WAV_FLOAT = $50003;
  BASS_CTYPE_MUSIC_MOD    = $20000;
  BASS_CTYPE_MUSIC_MTM    = $20001;
  BASS_CTYPE_MUSIC_S3M    = $20002;
  BASS_CTYPE_MUSIC_XM     = $20003;
  BASS_CTYPE_MUSIC_IT     = $20004;
  BASS_CTYPE_MUSIC_MO3    = $00100; // MO3 flag

  // 3D channel modes
  BASS_3DMODE_NORMAL      = 0; // normal 3D processing
  BASS_3DMODE_RELATIVE    = 1; // position is relative to the listener
  BASS_3DMODE_OFF         = 2; // no 3D processing

  // software 3D mixing algorithms (used with BASS_CONFIG_3DALGORITHM)
  BASS_3DALG_DEFAULT      = 0;
  BASS_3DALG_OFF          = 1;
  BASS_3DALG_FULL         = 2;
  BASS_3DALG_LIGHT        = 3;

  // EAX environments, use with BASS_SetEAXParameters
  EAX_ENVIRONMENT_GENERIC           = 0;
  EAX_ENVIRONMENT_PADDEDCELL        = 1;
  EAX_ENVIRONMENT_ROOM              = 2;
  EAX_ENVIRONMENT_BATHROOM          = 3;
  EAX_ENVIRONMENT_LIVINGROOM        = 4;
  EAX_ENVIRONMENT_STONEROOM         = 5;
  EAX_ENVIRONMENT_AUDITORIUM        = 6;
  EAX_ENVIRONMENT_CONCERTHALL       = 7;
  EAX_ENVIRONMENT_CAVE              = 8;
  EAX_ENVIRONMENT_ARENA             = 9;
  EAX_ENVIRONMENT_HANGAR            = 10;
  EAX_ENVIRONMENT_CARPETEDHALLWAY   = 11;
  EAX_ENVIRONMENT_HALLWAY           = 12;
  EAX_ENVIRONMENT_STONECORRIDOR     = 13;
  EAX_ENVIRONMENT_ALLEY             = 14;
  EAX_ENVIRONMENT_FOREST            = 15;
  EAX_ENVIRONMENT_CITY              = 16;
  EAX_ENVIRONMENT_MOUNTAINS         = 17;
  EAX_ENVIRONMENT_QUARRY            = 18;
  EAX_ENVIRONMENT_PLAIN             = 19;
  EAX_ENVIRONMENT_PARKINGLOT        = 20;
  EAX_ENVIRONMENT_SEWERPIPE         = 21;
  EAX_ENVIRONMENT_UNDERWATER        = 22;
  EAX_ENVIRONMENT_DRUGGED           = 23;
  EAX_ENVIRONMENT_DIZZY             = 24;
  EAX_ENVIRONMENT_PSYCHOTIC         = 25;
  // total number of environments
  EAX_ENVIRONMENT_COUNT             = 26;

  BASS_STREAMPROC_END = $80000000; // end of user stream flag


  // BASS_StreamCreateFileUser file systems
  STREAMFILE_NOBUFFER     = 0;
  STREAMFILE_BUFFER       = 1;
  STREAMFILE_BUFFERPUSH   = 2;

  // BASS_StreamPutFileData options
  BASS_FILEDATA_END       = 0; // end & close the file

  // BASS_StreamGetFilePosition modes
  BASS_FILEPOS_CURRENT    = 0;
  BASS_FILEPOS_DECODE     = BASS_FILEPOS_CURRENT;
  BASS_FILEPOS_DOWNLOAD   = 1;
  BASS_FILEPOS_END        = 2;
  BASS_FILEPOS_START      = 3;
  BASS_FILEPOS_CONNECTED  = 4;
  BASS_FILEPOS_BUFFER     = 5;

  // BASS_ChannelSetSync types
  BASS_SYNC_POS           = 0;
  BASS_SYNC_END           = 2;
  BASS_SYNC_META          = 4;
  BASS_SYNC_SLIDE         = 5;
  BASS_SYNC_STALL         = 6;
  BASS_SYNC_DOWNLOAD      = 7;
  BASS_SYNC_FREE          = 8;
  BASS_SYNC_SETPOS        = 11;
  BASS_SYNC_MUSICPOS      = 10;
  BASS_SYNC_MUSICINST     = 1;
  BASS_SYNC_MUSICFX       = 3;
  BASS_SYNC_OGG_CHANGE    = 12;
  BASS_SYNC_MIXTIME       = $40000000; // FLAG: sync at mixtime, else at playtime
  BASS_SYNC_ONETIME       = $80000000; // FLAG: sync only once, else continuously

  // BASS_ChannelIsActive return values
  BASS_ACTIVE_STOPPED = 0;
  BASS_ACTIVE_PLAYING = 1;
  BASS_ACTIVE_STALLED = 2;
  BASS_ACTIVE_PAUSED  = 3;

  // Channel attributes
  BASS_ATTRIB_FREQ                  = 1;
  BASS_ATTRIB_VOL                   = 2;
  BASS_ATTRIB_PAN                   = 3;
  BASS_ATTRIB_EAXMIX                = 4;
  BASS_ATTRIB_MUSIC_AMPLIFY         = $100;
  BASS_ATTRIB_MUSIC_PANSEP          = $101;
  BASS_ATTRIB_MUSIC_PSCALER         = $102;
  BASS_ATTRIB_MUSIC_BPM             = $103;
  BASS_ATTRIB_MUSIC_SPEED           = $104;
  BASS_ATTRIB_MUSIC_VOL_GLOBAL      = $105;
  BASS_ATTRIB_MUSIC_VOL_CHAN        = $200; // + channel #
  BASS_ATTRIB_MUSIC_VOL_INST        = $300; // + instrument #

  // BASS_ChannelGetData flags
  BASS_DATA_AVAILABLE = 0;        // query how much data is buffered
  BASS_DATA_FLOAT     = $40000000; // flag: return floating-point sample data
  BASS_DATA_FFT256    = $80000000; // 256 sample FFT
  BASS_DATA_FFT512    = $80000001; // 512 FFT
  BASS_DATA_FFT1024   = $80000002; // 1024 FFT
  BASS_DATA_FFT2048   = $80000003; // 2048 FFT
  BASS_DATA_FFT4096   = $80000004; // 4096 FFT
  BASS_DATA_FFT8192   = $80000005; // 8192 FFT
  BASS_DATA_FFT_INDIVIDUAL = $10; // FFT flag: FFT for each channel, else all combined
  BASS_DATA_FFT_NOWINDOW = $20;   // FFT flag: no Hanning window

  // BASS_ChannelGetTags types : what's returned
  BASS_TAG_ID3        = 0; // ID3v1 tags : TAG_ID3 structure
  BASS_TAG_ID3V2      = 1; // ID3v2 tags : variable length block
  BASS_TAG_OGG        = 2; // OGG comments : series of null-terminated UTF-8 strings
  BASS_TAG_HTTP       = 3; // HTTP headers : series of null-terminated ANSI strings
  BASS_TAG_ICY        = 4; // ICY headers : series of null-terminated ANSI strings
  BASS_TAG_META       = 5; // ICY metadata : ANSI string
  BASS_TAG_VENDOR     = 9; // OGG encoder : UTF-8 string
  BASS_TAG_LYRICS3    = 10; // Lyric3v2 tag : ASCII string
  BASS_TAG_RIFF_INFO  = $100; // RIFF "INFO" tags : series of null-terminated ANSI strings
  BASS_TAG_RIFF_BEXT  = $101; // RIFF/BWF Broadcast Audio Extension tags : TAG_BEXT structure
  BASS_TAG_MUSIC_NAME = $10000;	// MOD music name : ANSI string
  BASS_TAG_MUSIC_MESSAGE = $10001; // MOD message : ANSI string
  BASS_TAG_MUSIC_INST = $10100;	// + instrument #, MOD instrument name : ANSI string
  BASS_TAG_MUSIC_SAMPLE = $10300; // + sample #, MOD sample name : ANSI string

  // BASS_ChannelGetLength/GetPosition/SetPosition modes
  BASS_POS_BYTE           = 0; // byte position
  BASS_POS_MUSIC_ORDER    = 1; // order.row position, MAKELONG(order,row)

  // BASS_RecordSetInput flags
  BASS_INPUT_OFF    = $10000;
  BASS_INPUT_ON     = $20000;

  BASS_INPUT_TYPE_MASK    = $FF000000;
  BASS_INPUT_TYPE_UNDEF   = $00000000;
  BASS_INPUT_TYPE_DIGITAL = $01000000;
  BASS_INPUT_TYPE_LINE    = $02000000;
  BASS_INPUT_TYPE_MIC     = $03000000;
  BASS_INPUT_TYPE_SYNTH   = $04000000;
  BASS_INPUT_TYPE_CD      = $05000000;
  BASS_INPUT_TYPE_PHONE   = $06000000;
  BASS_INPUT_TYPE_SPEAKER = $07000000;
  BASS_INPUT_TYPE_WAVE    = $08000000;
  BASS_INPUT_TYPE_AUX     = $09000000;
  BASS_INPUT_TYPE_ANALOG  = $0A000000;

  BASS_FX_DX8_CHORUS	  = 0;
  BASS_FX_DX8_COMPRESSOR  = 1;
  BASS_FX_DX8_DISTORTION  = 2;
  BASS_FX_DX8_ECHO        = 3;
  BASS_FX_DX8_FLANGER     = 4;
  BASS_FX_DX8_GARGLE      = 5;
  BASS_FX_DX8_I3DL2REVERB = 6;
  BASS_FX_DX8_PARAMEQ     = 7;
  BASS_FX_DX8_REVERB      = 8;

  BASS_DX8_PHASE_NEG_180 = 0;
  BASS_DX8_PHASE_NEG_90  = 1;
  BASS_DX8_PHASE_ZERO    = 2;
  BASS_DX8_PHASE_90      = 3;
  BASS_DX8_PHASE_180     = 4;

type
  DWORD = cardinal;
  BOOL = LongBool;
  FLOAT = Single;
  QWORD = int64;        // 64-bit (replace "int64" with "comp" if using Delphi 3)

  HMUSIC = DWORD;       // MOD music handle
  HSAMPLE = DWORD;      // sample handle
  HCHANNEL = DWORD;     // playing sample's channel handle
  HSTREAM = DWORD;      // sample stream handle
  HRECORD = DWORD;      // recording handle
  HSYNC = DWORD;        // synchronizer handle
  HDSP = DWORD;         // DSP handle
  HFX = DWORD;          // DX8 effect handle
  HPLUGIN = DWORD;      // Plugin handle

  // Device info structure
  BASS_DEVICEINFO = record
    name: PAnsiChar;        // description
    driver: PAnsiChar;      // driver
    flags: DWORD;
  end;

  BASS_INFO = record
    flags: DWORD;       // device capabilities (DSCAPS_xxx flags)
    hwsize: DWORD;      // size of total device hardware memory
    hwfree: DWORD;      // size of free device hardware memory
    freesam: DWORD;     // number of free sample slots in the hardware
    free3d: DWORD;      // number of free 3D sample slots in the hardware
    minrate: DWORD;     // min sample rate supported by the hardware
    maxrate: DWORD;     // max sample rate supported by the hardware
    eax: BOOL;          // device supports EAX? (always FALSE if BASS_DEVICE_3D was not used)
    minbuf: DWORD;      // recommended minimum buffer length in ms (requires BASS_DEVICE_LATENCY)
    dsver: DWORD;       // DirectSound version
    latency: DWORD;     // delay (in ms) before start of playback (requires BASS_DEVICE_LATENCY)
    initflags: DWORD;   // BASS_Init "flags" parameter
    speakers: DWORD;    // number of speakers available
    freq: DWORD;        // current output rate (OSX only)
  end;

  // Recording device info structure
  BASS_RECORDINFO = record
    flags: DWORD;       // device capabilities (DSCCAPS_xxx flags)
    formats: DWORD;     // supported standard formats (WAVE_FORMAT_xxx flags)
    inputs: DWORD;      // number of inputs
    singlein: BOOL;     // only 1 input can be set at a time
    freq: DWORD;        // current input rate (OSX only)
  end;

  // Sample info structure
  BASS_SAMPLE = record
    freq: DWORD;        // default playback rate
    volume: FLOAT;      // default volume (0-100)
    pan: FLOAT;         // default pan (-100=left, 0=middle, 100=right)
    flags: DWORD;       // BASS_SAMPLE_xxx flags
    length: DWORD;      // length (in samples, not bytes)
    max: DWORD;         // maximum simultaneous playbacks
    origres: DWORD;     // original resolution
    chans: DWORD;       // number of channels
    mingap: DWORD;      // minimum gap (ms) between creating channels
    mode3d: DWORD;      // BASS_3DMODE_xxx mode
    mindist: FLOAT;     // minimum distance
    maxdist: FLOAT;     // maximum distance
    iangle: DWORD;      // angle of inside projection cone
    oangle: DWORD;      // angle of outside projection cone
    outvol: FLOAT;      // delta-volume outside the projection cone
    vam: DWORD;         // voice allocation/management flags (BASS_VAM_xxx)
    priority: DWORD;    // priority (0=lowest, $ffffffff=highest)
  end;

  // Channel info structure
  BASS_CHANNELINFO = record
    freq: DWORD;        // default playback rate
    chans: DWORD;       // channels
    flags: DWORD;       // BASS_SAMPLE/STREAM/MUSIC/SPEAKER flags
    ctype: DWORD;       // type of channel
    origres: DWORD;     // original resolution
    plugin: HPLUGIN;    // plugin
    sample: HSAMPLE;    // sample
    filename: PAnsiChar;    // filename
  end;

  BASS_PLUGINFORM = record
    ctype: DWORD;       // channel type
    name: PAnsiChar;        // format description
    exts: PAnsiChar;	    // file extension filter (*.ext1;*.ext2;etc...)
  end;
  PBASS_PLUGINFORMS = ^TBASS_PLUGINFORMS;
  TBASS_PLUGINFORMS = array[0..maxInt div sizeOf(BASS_PLUGINFORM) - 1] of BASS_PLUGINFORM;

  BASS_PLUGININFO = record
    version: DWORD;             // version (same form as BASS_GetVersion)
    formatc: DWORD;             // number of formats
    formats: PBASS_PLUGINFORMS; // the array of formats
  end;
  PBASS_PLUGININFO = ^BASS_PLUGININFO;

  // 3D vector (for 3D positions/velocities/orientations)
  BASS_3DVECTOR = record
    x: FLOAT;           // +=right, -=left
    y: FLOAT;           // +=up, -=down
    z: FLOAT;           // +=front, -=behind
  end;

  // User file stream callback functions
  FILECLOSEPROC = procedure(user: Pointer); stdcall;
  FILELENPROC = function(user: Pointer): QWORD; stdcall;
  FILEREADPROC = function(buffer: Pointer; length: DWORD; user: Pointer): DWORD; stdcall;
  FILESEEKPROC = function(offset: QWORD; user: Pointer): BOOL; stdcall;

  BASS_FILEPROCS = record
    close: FILECLOSEPROC;
    length: FILELENPROC;
    read: FILEREADPROC;
    seek: FILESEEKPROC;
  end;

  // ID3v1 tag structure
  TAG_ID3 = record
    id: Array[0..2] of AnsiChar;
    title: Array[0..29] of AnsiChar;
    artist: Array[0..29] of AnsiChar;
    album: Array[0..29] of AnsiChar;
    year: Array[0..3] of AnsiChar;
    comment: Array[0..29] of AnsiChar;
    genre: Byte;
  end;

  // BWF Broadcast Audio Extension tag structure
  TAG_BEXT = record
    Description: Array[0..255] of AnsiChar;     // description
    Originator: Array[0..31] of AnsiChar;       // name of the originator
    OriginatorReference: Array[0..31] of AnsiChar; // reference of the originator
    OriginationDate: Array[0..9] of AnsiChar;   // date of creation (yyyy-mm-dd)
    OriginationTime: Array[0..7] of AnsiChar;   // time of creation (hh-mm-ss)
    TimeReference: QWORD;                       // first sample count since midnight (little-endian)
    Version: Word;                              // BWF version (little-endian)
    UMID: Array[0..63] of Byte;                 // SMPTE UMID
    Reserved: Array[0..189] of Byte;
    CodingHistory: Array of AnsiChar;           // history
  end;

  BASS_DX8_CHORUS = record
    fWetDryMix: FLOAT;
    fDepth: FLOAT;
    fFeedback: FLOAT;
    fFrequency: FLOAT;
    lWaveform: DWORD;   // 0=triangle, 1=sine
    fDelay: FLOAT;
    lPhase: DWORD;      // BASS_DX8_PHASE_xxx
  end;

  BASS_DX8_COMPRESSOR = record
    fGain: FLOAT;
    fAttack: FLOAT;
    fRelease: FLOAT;
    fThreshold: FLOAT;
    fRatio: FLOAT;
    fPredelay: FLOAT;
  end;

  BASS_DX8_DISTORTION = record
    fGain: FLOAT;
    fEdge: FLOAT;
    fPostEQCenterFrequency: FLOAT;
    fPostEQBandwidth: FLOAT;
    fPreLowpassCutoff: FLOAT;
  end;

  BASS_DX8_ECHO = record
    fWetDryMix: FLOAT;
    fFeedback: FLOAT;
    fLeftDelay: FLOAT;
    fRightDelay: FLOAT;
    lPanDelay: BOOL;
  end;

  BASS_DX8_FLANGER = record
    fWetDryMix: FLOAT;
    fDepth: FLOAT;
    fFeedback: FLOAT;
    fFrequency: FLOAT;
    lWaveform: DWORD;   // 0=triangle, 1=sine
    fDelay: FLOAT;
    lPhase: DWORD;      // BASS_DX8_PHASE_xxx
  end;

  BASS_DX8_GARGLE = record
    dwRateHz: DWORD;               // Rate of modulation in hz
    dwWaveShape: DWORD;            // 0=triangle, 1=square
  end;

  BASS_DX8_I3DL2REVERB = record
    lRoom: Longint;                // [-10000, 0]      default: -1000 mB
    lRoomHF: Longint;              // [-10000, 0]      default: 0 mB
    flRoomRolloffFactor: FLOAT;    // [0.0, 10.0]      default: 0.0
    flDecayTime: FLOAT;            // [0.1, 20.0]      default: 1.49s
    flDecayHFRatio: FLOAT;         // [0.1, 2.0]       default: 0.83
    lReflections: Longint;         // [-10000, 1000]   default: -2602 mB
    flReflectionsDelay: FLOAT;     // [0.0, 0.3]       default: 0.007 s
    lReverb: Longint;              // [-10000, 2000]   default: 200 mB
    flReverbDelay: FLOAT;          // [0.0, 0.1]       default: 0.011 s
    flDiffusion: FLOAT;            // [0.0, 100.0]     default: 100.0 %
    flDensity: FLOAT;              // [0.0, 100.0]     default: 100.0 %
    flHFReference: FLOAT;          // [20.0, 20000.0]  default: 5000.0 Hz
  end;

  BASS_DX8_PARAMEQ = record
    fCenter: FLOAT;
    fBandwidth: FLOAT;
    fGain: FLOAT;
  end;

  BASS_DX8_REVERB = record
    fInGain: FLOAT;                // [-96.0,0.0]            default: 0.0 dB
    fReverbMix: FLOAT;             // [-96.0,0.0]            default: 0.0 db
    fReverbTime: FLOAT;            // [0.001,3000.0]         default: 1000.0 ms
    fHighFreqRTRatio: FLOAT;       // [0.001,0.999]          default: 0.001
  end;

  // callback function types
  STREAMPROC = function(handle: HSTREAM; buffer: Pointer; length: DWORD; user: Pointer): DWORD; stdcall;
  {
    User stream callback function. NOTE: A stream function should obviously be as
    quick as possible, other streams (and MOD musics) can't be mixed until
    it's finished.
    handle : The stream that needs writing
    buffer : Buffer to write the samples in
    length : Number of bytes to write
    user   : The 'user' parameter value given when calling BASS_StreamCreate
    RETURN : Number of bytes written. Set the BASS_STREAMPROC_END flag to end
             the stream.
  }

const
  // special STREAMPROCs
  STREAMPROC_DUMMY : STREAMPROC = STREAMPROC(0);  // "dummy" stream
  STREAMPROC_PUSH  : STREAMPROC = STREAMPROC(-1); // push stream

type

  DOWNLOADPROC = procedure(buffer: Pointer; length: DWORD; user: Pointer); stdcall;
  {
    Internet stream download callback function.
    buffer : Buffer containing the downloaded data... NULL=end of download
    length : Number of bytes in the buffer
    user   : The 'user' parameter value given when calling BASS_StreamCreateURL
  }

  SYNCPROC = procedure(handle: HSYNC; channel, data: DWORD; user: Pointer); stdcall;
  {
    Sync callback function. NOTE: a sync callback function should be very
    quick as other syncs cannot be processed until it has finished. If the
    sync is a "mixtime" sync, then other streams and MOD musics can not be
    mixed until it's finished either.
    handle : The sync that has occured
    channel: Channel that the sync occured in
    data   : Additional data associated with the sync's occurance
    user   : The 'user' parameter given when calling BASS_ChannelSetSync
  }

  DSPPROC = procedure(handle: HDSP; channel: DWORD; buffer: Pointer; length: DWORD; user: Pointer); stdcall;
  {
    DSP callback function. NOTE: A DSP function should obviously be as quick
    as possible... other DSP functions, streams and MOD musics can not be
    processed until it's finished.
    handle : The DSP handle
    channel: Channel that the DSP is being applied to
    buffer : Buffer to apply the DSP to
    length : Number of bytes in the buffer
    user   : The 'user' parameter given when calling BASS_ChannelSetDSP
  }

  RECORDPROC = function(handle: HRECORD; buffer: Pointer; length: DWORD; user: Pointer): BOOL; stdcall;
  {
    Recording callback function.
    handle : The recording handle
    buffer : Buffer containing the recorded sample data
    length : Number of bytes
    user   : The 'user' parameter value given when calling BASS_RecordStart
    RETURN : TRUE = continue recording, FALSE = stop
  }


// Functions
{const
  bassdll = 'bass.dll';}
{
function BASS_SetConfig(option, value: DWORD): BOOL; stdcall; external bassdll;
function BASS_GetConfig(option: DWORD): DWORD; stdcall; external bassdll;
function BASS_SetConfigPtr(option: DWORD; value: Pointer): BOOL; stdcall; external bassdll;
function BASS_GetConfigPtr(option: DWORD): Pointer; stdcall; external bassdll;
function BASS_GetVersion: DWORD; stdcall; external bassdll;
function BASS_ErrorGetCode: Integer; stdcall; external bassdll;
function BASS_GetDeviceInfo(device: DWORD; var info: BASS_DEVICEINFO): BOOL; stdcall; external bassdll;
function BASS_Init(device: Integer; freq, flags: DWORD; win: HWND; clsid: PGUID): BOOL; stdcall; external bassdll;
function BASS_SetDevice(device: DWORD): BOOL; stdcall; external bassdll;
function BASS_GetDevice: DWORD; stdcall; external bassdll;
function BASS_Free: BOOL; stdcall; external bassdll;
function BASS_GetDSoundObject(obj: DWORD): Pointer; stdcall; external bassdll;
function BASS_GetInfo(var info: BASS_INFO): BOOL; stdcall; external bassdll;
function BASS_Update(length: DWORD): BOOL; stdcall; external bassdll;
function BASS_GetCPU: FLOAT; stdcall; external bassdll;
function BASS_Start: BOOL; stdcall; external bassdll;
function BASS_Stop: BOOL; stdcall; external bassdll;
function BASS_Pause: BOOL; stdcall; external bassdll;
function BASS_SetVolume(volume: FLOAT): BOOL; stdcall; external bassdll;
function BASS_GetVolume: FLOAT; stdcall; external bassdll;

function BASS_PluginLoad(filename: PAnsiChar; flags: DWORD): HPLUGIN; stdcall; external bassdll;
function BASS_PluginFree(handle: HPLUGIN): BOOL; stdcall; external bassdll;
function BASS_PluginGetInfo(handle: HPLUGIN): PBASS_PLUGININFO; stdcall; external bassdll;

function BASS_Set3DFactors(distf, rollf, doppf: FLOAT): BOOL; stdcall; external bassdll;
function BASS_Get3DFactors(var distf, rollf, doppf: FLOAT): BOOL; stdcall; external bassdll;
function BASS_Set3DPosition(var pos, vel, front, top: BASS_3DVECTOR): BOOL; stdcall; external bassdll;
function BASS_Get3DPosition(var pos, vel, front, top: BASS_3DVECTOR): BOOL; stdcall; external bassdll;
procedure BASS_Apply3D; stdcall; external bassdll;
function BASS_SetEAXParameters(env: Integer; vol, decay, damp: FLOAT): BOOL; stdcall; external bassdll;
function BASS_GetEAXParameters(var env: DWORD; var vol, decay, damp: FLOAT): BOOL; stdcall; external bassdll;

function BASS_MusicLoad(mem: BOOL; f: Pointer; offset: QWORD; length, flags, freq: DWORD): HMUSIC; stdcall; external bassdll;
function BASS_MusicFree(handle: HMUSIC): BOOL; stdcall; external bassdll;

function BASS_SampleLoad(mem: BOOL; f: Pointer; offset: QWORD; length, max, flags: DWORD): HSAMPLE; stdcall; external bassdll;
function BASS_SampleCreate(length, freq, chans, max, flags: DWORD): HSAMPLE; stdcall; external bassdll;
function BASS_SampleFree(handle: HSAMPLE): BOOL; stdcall; external bassdll;
function BASS_SampleSetData(handle: HSAMPLE; buffer: Pointer): BOOL; stdcall; external bassdll;
function BASS_SampleGetData(handle: HSAMPLE; buffer: Pointer): BOOL; stdcall; external bassdll;
function BASS_SampleGetInfo(handle: HSAMPLE; var info: BASS_SAMPLE): BOOL; stdcall; external bassdll;
function BASS_SampleSetInfo(handle: HSAMPLE; var info: BASS_SAMPLE): BOOL; stdcall; external bassdll;
function BASS_SampleGetChannel(handle: HSAMPLE; onlynew: BOOL): HCHANNEL; stdcall; external bassdll;
function BASS_SampleGetChannels(handle: HSAMPLE; channels: Pointer): DWORD; stdcall; external bassdll;
function BASS_SampleStop(handle: HSAMPLE): BOOL; stdcall; external bassdll;

function BASS_StreamCreate(freq, chans, flags: DWORD; proc: STREAMPROC; user: Pointer): HSTREAM; stdcall; external bassdll;
function BASS_StreamCreateFile(mem: BOOL; f: Pointer; offset, length: QWORD; flags: DWORD): HSTREAM; stdcall; external bassdll;
function BASS_StreamCreateURL(url: PAnsiChar; offset: DWORD; flags: DWORD; proc: DOWNLOADPROC; user: Pointer):HSTREAM; stdcall; external bassdll;
function BASS_StreamCreateFileUser(system, flags: DWORD; var procs: BASS_FILEPROCS; user: Pointer): HSTREAM; stdcall; external bassdll;
function BASS_StreamFree(handle: HSTREAM): BOOL; stdcall; external bassdll;
function BASS_StreamGetFilePosition(handle: HSTREAM; mode: DWORD): QWORD; stdcall; external bassdll;
function BASS_StreamPutData(handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD; stdcall; external bassdll;
function BASS_StreamPutFileData(handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD; stdcall; external bassdll;

function BASS_RecordGetDeviceInfo(device: DWORD; var info: BASS_DEVICEINFO): BOOL; stdcall; external bassdll;
function BASS_RecordInit(device: Integer):BOOL; stdcall; external bassdll;
function BASS_RecordSetDevice(device: DWORD): BOOL; stdcall; external bassdll;
function BASS_RecordGetDevice: DWORD; stdcall; external bassdll;
function BASS_RecordFree: BOOL; stdcall; external bassdll;
function BASS_RecordGetInfo(var info: BASS_RECORDINFO): BOOL; stdcall; external bassdll;
function BASS_RecordGetInputName(input: Integer): PAnsiChar; stdcall; external bassdll;
function BASS_RecordSetInput(input: Integer; flags: DWORD; volume: FLOAT): BOOL; stdcall; external bassdll;
function BASS_RecordGetInput(input: Integer; var volume: FLOAT): DWORD; stdcall; external bassdll;
function BASS_RecordStart(freq, chans, flags: DWORD; proc: RECORDPROC; user: Pointer): HRECORD; stdcall; external bassdll;

function BASS_ChannelBytes2Seconds(handle: DWORD; pos: QWORD): Double; stdcall;external bassdll;
function BASS_ChannelSeconds2Bytes(handle: DWORD; pos: Double): QWORD; stdcall;external bassdll;
function BASS_ChannelGetDevice(handle: DWORD): DWORD; stdcall; external bassdll;
function BASS_ChannelSetDevice(handle, device: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelIsActive(handle: DWORD): DWORD; stdcall;external bassdll;
function BASS_ChannelGetInfo(handle: DWORD; var info: BASS_CHANNELINFO):BOOL;stdcall;external bassdll;
function BASS_ChannelGetTags(handle: HSTREAM; tags: DWORD): PAnsiChar; stdcall; external bassdll;
function BASS_ChannelFlags(handle, flags, mask: DWORD): DWORD; stdcall; external bassdll;
function BASS_ChannelUpdate(handle, length: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelLock(handle: DWORD; lock: BOOL): BOOL; stdcall; external bassdll;
function BASS_ChannelPlay(handle: DWORD; restart: BOOL): BOOL; stdcall; external bassdll;
function BASS_ChannelStop(handle: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelPause(handle: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelSetAttribute(handle, attrib: DWORD; value: FLOAT): BOOL; stdcall; external bassdll;
function BASS_ChannelGetAttribute(handle, attrib: DWORD; var value: FLOAT): BOOL; stdcall; external bassdll;
function BASS_ChannelSlideAttribute(handle, attrib: DWORD; value: FLOAT; time: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelIsSliding(handle, attrib: DWORD): BOOL; stdcall;external bassdll;
function BASS_ChannelSet3DAttributes(handle: DWORD; mode: Integer; min, max: FLOAT; iangle, oangle, outvol: Integer): BOOL; stdcall; external bassdll;
function BASS_ChannelGet3DAttributes(handle: DWORD; var mode: DWORD; var min, max: FLOAT; var iangle, oangle, outvol: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelSet3DPosition(handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL; stdcall; external bassdll;
function BASS_ChannelGet3DPosition(handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL; stdcall; external bassdll;
function BASS_ChannelGetLength(handle, mode: DWORD): QWORD; stdcall; external bassdll;
function BASS_ChannelSetPosition(handle: DWORD; pos: QWORD; mode: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelGetPosition(handle, mode: DWORD): QWORD; stdcall; external bassdll;
function BASS_ChannelGetLevel(handle: DWORD): DWORD; stdcall; external bassdll;
function BASS_ChannelGetData(handle: DWORD; buffer: Pointer; length: DWORD): DWORD; stdcall; external bassdll;
function BASS_ChannelSetSync(handle: DWORD; type_: DWORD; param: QWORD; proc: SYNCPROC; user: Pointer): HSYNC; stdcall; external bassdll;
function BASS_ChannelRemoveSync(handle: DWORD; sync: HSYNC): BOOL; stdcall; external bassdll;
function BASS_ChannelSetDSP(handle: DWORD; proc: DSPPROC; user: Pointer; priority: Integer): HDSP; stdcall; external bassdll;
function BASS_ChannelRemoveDSP(handle: DWORD; dsp: HDSP): BOOL; stdcall; external bassdll;
function BASS_ChannelSetLink(handle, chan: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelRemoveLink(handle, chan: DWORD): BOOL; stdcall; external bassdll;
function BASS_ChannelSetFX(handle, type_: DWORD; priority: Integer): HFX; stdcall; external bassdll;
function BASS_ChannelRemoveFX(handle: DWORD; fx: HFX): BOOL; stdcall; external bassdll;

function BASS_FXSetParameters(handle: HFX; par: Pointer): BOOL; stdcall; external bassdll;
function BASS_FXGetParameters(handle: HFX; par: Pointer): BOOL; stdcall; external bassdll;
function BASS_FXReset(handle: HFX): BOOL; stdcall; external bassdll;
}




function BASS_SPEAKER_N(n: DWORD): DWORD;
function BASS_SetEAXPreset(env: Integer): BOOL;
{
  This function is defined in the implementation part of this unit.
  It is not part of BASS.DLL but an extra function which makes it easier
  to set the predefined EAX environments.
  env    : a EAX_ENVIRONMENT_xxx constant
}












type
TBASS_SetConfig           = function(option, value: DWORD): BOOL; stdcall;
TBASS_GetConfig           = function (option: DWORD): DWORD; stdcall;
TBASS_SetConfigPtr        = function (option: DWORD; value: Pointer): BOOL; stdcall;
TBASS_GetConfigPtr        = function (option: DWORD): Pointer; stdcall;
TBASS_GetVersion          = function (): DWORD; stdcall;
TBASS_ErrorGetCode        = function (): Integer; stdcall;
TBASS_GetDeviceInfo       = function (device: DWORD; var info: BASS_DEVICEINFO): BOOL; stdcall;
TBASS_Init                = function (device: Integer; freq, flags: DWORD; win: HWND; clsid: PGUID): BOOL; stdcall;
TBASS_SetDevice           = function (device: DWORD): BOOL; stdcall;
TBASS_GetDevice           = function (): DWORD; stdcall;
TBASS_Free                = function (): BOOL; stdcall;
TBASS_GetDSoundObject     = function (obj: DWORD): Pointer; stdcall;
TBASS_GetInfo             = function (var info: BASS_INFO): BOOL; stdcall;
TBASS_Update              = function (length: DWORD): BOOL; stdcall;
TBASS_GetCPU              = function (): FLOAT; stdcall;
TBASS_Start               = function (): BOOL; stdcall;
TBASS_Stop                = function (): BOOL; stdcall;
TBASS_Pause               = function (): BOOL; stdcall;
TBASS_SetVolume           = function (volume: FLOAT): BOOL; stdcall;
TBASS_GetVolume           = function (): FLOAT; stdcall;

TBASS_PluginLoad          = function (filename: PAnsiChar; flags: DWORD): HPLUGIN; stdcall;
TBASS_PluginFree          = function (handle: HPLUGIN): BOOL; stdcall;
TBASS_PluginGetInfo       = function (handle: HPLUGIN): PBASS_PLUGININFO; stdcall;

TBASS_Set3DFactors        = function (distf, rollf, doppf: FLOAT): BOOL; stdcall;
TBASS_Get3DFactors        = function (var distf, rollf, doppf: FLOAT): BOOL; stdcall;
TBASS_Set3DPosition       = function (var pos, vel, front, top: BASS_3DVECTOR): BOOL; stdcall;
TBASS_Get3DPosition       = function (var pos, vel, front, top: BASS_3DVECTOR): BOOL; stdcall;
TBASS_Apply3D             = procedure (); stdcall;
TBASS_SetEAXParameters    = function (env: Integer; vol, decay, damp: FLOAT): BOOL; stdcall;
TBASS_GetEAXParameters    = function (var env: DWORD; var vol, decay, damp: FLOAT): BOOL; stdcall;

TBASS_MusicLoad           = function (mem: BOOL; f: Pointer; offset: QWORD; length, flags, freq: DWORD): HMUSIC; stdcall;
TBASS_MusicFree           = function (handle: HMUSIC): BOOL; stdcall;

TBASS_SampleLoad          = function (mem: BOOL; f: Pointer; offset: QWORD; length, max, flags: DWORD): HSAMPLE; stdcall;
TBASS_SampleCreate        = function (length, freq, chans, max, flags: DWORD): HSAMPLE; stdcall;
TBASS_SampleFree          = function (handle: HSAMPLE): BOOL; stdcall;
TBASS_SampleSetData       = function (handle: HSAMPLE; buffer: Pointer): BOOL; stdcall;
TBASS_SampleGetData       = function (handle: HSAMPLE; buffer: Pointer): BOOL; stdcall;
TBASS_SampleGetInfo       = function (handle: HSAMPLE; var info: BASS_SAMPLE): BOOL; stdcall;
TBASS_SampleSetInfo       = function (handle: HSAMPLE; var info: BASS_SAMPLE): BOOL; stdcall;
TBASS_SampleGetChannel    = function (handle: HSAMPLE; onlynew: BOOL): HCHANNEL; stdcall;
TBASS_SampleGetChannels   = function (handle: HSAMPLE; channels: Pointer): DWORD; stdcall;
TBASS_SampleStop          = function (handle: HSAMPLE): BOOL; stdcall;

TBASS_StreamCreate        = function (freq, chans, flags: DWORD; proc: STREAMPROC; user: Pointer): HSTREAM; stdcall;
TBASS_StreamCreateFile    = function (mem: BOOL; f: Pointer; offset, length: QWORD; flags: DWORD): HSTREAM; stdcall;
TBASS_StreamCreateURL     = function (url: PAnsiChar; offset: DWORD; flags: DWORD; proc: DOWNLOADPROC; user: Pointer):HSTREAM; stdcall;
TBASS_StreamCreateFileUser= function (system, flags: DWORD; var procs: BASS_FILEPROCS; user: Pointer): HSTREAM; stdcall;
TBASS_StreamFree          = function (handle: HSTREAM): BOOL; stdcall;
TBASS_StreamGetFilePosition=function (handle: HSTREAM; mode: DWORD): QWORD; stdcall;
TBASS_StreamPutData       = function (handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD; stdcall;
TBASS_StreamPutFileData   = function (handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD; stdcall;

TBASS_RecordGetDeviceInfo = function (device: DWORD; var info: BASS_DEVICEINFO): BOOL; stdcall;
TBASS_RecordInit          = function (device: Integer):BOOL; stdcall;
TBASS_RecordSetDevice     = function (device: DWORD): BOOL; stdcall;
TBASS_RecordGetDevice     = function (): DWORD; stdcall;
TBASS_RecordFree          = function (): BOOL; stdcall;
TBASS_RecordGetInfo       = function (var info: BASS_RECORDINFO): BOOL; stdcall;
TBASS_RecordGetInputName  = function (input: Integer): PAnsiChar; stdcall;
TBASS_RecordSetInput      = function (input: Integer; flags: DWORD; volume: FLOAT): BOOL; stdcall;
TBASS_RecordGetInput      = function (input: Integer; var volume: FLOAT): DWORD; stdcall;
TBASS_RecordStart         = function (freq, chans, flags: DWORD; proc: RECORDPROC; user: Pointer): HRECORD; stdcall;

TBASS_ChannelBytes2Seconds= function (handle: DWORD; pos: QWORD): Double; stdcall;
TBASS_ChannelSeconds2Bytes= function (handle: DWORD; pos: Double): QWORD; stdcall;
TBASS_ChannelGetDevice    = function (handle: DWORD): DWORD; stdcall;
TBASS_ChannelSetDevice    = function (handle, device: DWORD): BOOL; stdcall;
TBASS_ChannelIsActive     = function (handle: DWORD): DWORD; stdcall;
TBASS_ChannelGetInfo      = function (handle: DWORD; var info: BASS_CHANNELINFO):BOOL;stdcall;
TBASS_ChannelGetTags      = function (handle: HSTREAM; tags: DWORD): PAnsiChar; stdcall;
TBASS_ChannelFlags        = function (handle, flags, mask: DWORD): DWORD; stdcall;
TBASS_ChannelUpdate       = function (handle, length: DWORD): BOOL; stdcall;
TBASS_ChannelLock         = function (handle: DWORD; lock: BOOL): BOOL; stdcall;
TBASS_ChannelPlay         = function (handle: DWORD; restart: BOOL): BOOL; stdcall;
TBASS_ChannelStop         = function (handle: DWORD): BOOL; stdcall;
TBASS_ChannelPause        = function (handle: DWORD): BOOL; stdcall;
TBASS_ChannelSetAttribute = function (handle, attrib: DWORD; value: FLOAT): BOOL; stdcall;
TBASS_ChannelGetAttribute = function (handle, attrib: DWORD; var value: FLOAT): BOOL; stdcall;
TBASS_ChannelSlideAttribute=function (handle, attrib: DWORD; value: FLOAT; time: DWORD): BOOL; stdcall;
TBASS_ChannelIsSliding    = function (handle, attrib: DWORD): BOOL; stdcall;
TBASS_ChannelSet3DAttributes= function (handle: DWORD; mode: Integer; min, max: FLOAT; iangle, oangle, outvol: Integer): BOOL; stdcall;
TBASS_ChannelGet3DAttributes= function (handle: DWORD; var mode: DWORD; var min, max: FLOAT; var iangle, oangle, outvol: DWORD): BOOL; stdcall;
TBASS_ChannelSet3DPosition= function (handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL; stdcall;
TBASS_ChannelGet3DPosition= function (handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL; stdcall;
TBASS_ChannelGetLength    = function (handle, mode: DWORD): QWORD; stdcall;
TBASS_ChannelSetPosition  = function (handle: DWORD; pos: QWORD; mode: DWORD): BOOL; stdcall;
TBASS_ChannelGetPosition  = function (handle, mode: DWORD): QWORD; stdcall;
TBASS_ChannelGetLevel     = function (handle: DWORD): DWORD; stdcall;
TBASS_ChannelGetData      = function (handle: DWORD; buffer: Pointer; length: DWORD): DWORD; stdcall;
TBASS_ChannelSetSync      = function (handle: DWORD; type_: DWORD; param: QWORD; proc: SYNCPROC; user: Pointer): HSYNC; stdcall;
TBASS_ChannelRemoveSync   = function (handle: DWORD; sync: HSYNC): BOOL; stdcall;
TBASS_ChannelSetDSP       = function (handle: DWORD; proc: DSPPROC; user: Pointer; priority: Integer): HDSP; stdcall;
TBASS_ChannelRemoveDSP    = function (handle: DWORD; dsp: HDSP): BOOL; stdcall;
TBASS_ChannelSetLink      = function (handle, chan: DWORD): BOOL; stdcall;
TBASS_ChannelRemoveLink   = function (handle, chan: DWORD): BOOL; stdcall;
TBASS_ChannelSetFX        = function (handle, type_: DWORD; priority: Integer): HFX; stdcall;
TBASS_ChannelRemoveFX     = function (handle: DWORD; fx: HFX): BOOL; stdcall;

TBASS_FXSetParameters     = function (handle: HFX; par: Pointer): BOOL; stdcall;
TBASS_FXGetParameters     = function (handle: HFX; par: Pointer): BOOL; stdcall;
TBASS_FXReset             = function (handle: HFX): BOOL; stdcall;


function BASS_SetConfig(option, value: DWORD): BOOL;
function BASS_GetConfig(option: DWORD): DWORD;
function BASS_SetConfigPtr(option: DWORD; value: Pointer): BOOL;
function BASS_GetConfigPtr(option: DWORD): Pointer;
function BASS_GetVersion: DWORD;
function BASS_ErrorGetCode: Integer;
function BASS_GetDeviceInfo(device: DWORD; var info: BASS_DEVICEINFO): BOOL;
function BASS_Init(device: Integer; freq, flags: DWORD; win: HWND; clsid: PGUID): BOOL;
function BASS_SetDevice(device: DWORD): BOOL;
function BASS_GetDevice: DWORD;
function BASS_Free: BOOL;
function BASS_GetDSoundObject(obj: DWORD): Pointer;
function BASS_GetInfo(var info: BASS_INFO): BOOL;
function BASS_Update(length: DWORD): BOOL;
function BASS_GetCPU: FLOAT;
function BASS_Start: BOOL;
function BASS_Stop: BOOL;
function BASS_Pause: BOOL;
function BASS_SetVolume(volume: FLOAT): BOOL;
function BASS_GetVolume: FLOAT;

function BASS_PluginLoad(filename: PAnsiChar; flags: DWORD): HPLUGIN;
function BASS_PluginFree(handle: HPLUGIN): BOOL;
function BASS_PluginGetInfo(handle: HPLUGIN): PBASS_PLUGININFO;

function BASS_Set3DFactors(distf, rollf, doppf: FLOAT): BOOL;
function BASS_Get3DFactors(var distf, rollf, doppf: FLOAT): BOOL;
function BASS_Set3DPosition(var pos, vel, front, top: BASS_3DVECTOR): BOOL;
function BASS_Get3DPosition(var pos, vel, front, top: BASS_3DVECTOR): BOOL;
procedure BASS_Apply3D;
function BASS_SetEAXParameters(env: Integer; vol, decay, damp: FLOAT): BOOL;
function BASS_GetEAXParameters(var env: DWORD; var vol, decay, damp: FLOAT): BOOL;

function BASS_MusicLoad(mem: BOOL; f: Pointer; offset: QWORD; length, flags, freq: DWORD): HMUSIC;
function BASS_MusicFree(handle: HMUSIC): BOOL;

function BASS_SampleLoad(mem: BOOL; f: Pointer; offset: QWORD; length, max, flags: DWORD): HSAMPLE;
function BASS_SampleCreate(length, freq, chans, max, flags: DWORD): HSAMPLE;
function BASS_SampleFree(handle: HSAMPLE): BOOL;
function BASS_SampleSetData(handle: HSAMPLE; buffer: Pointer): BOOL;
function BASS_SampleGetData(handle: HSAMPLE; buffer: Pointer): BOOL;
function BASS_SampleGetInfo(handle: HSAMPLE; var info: BASS_SAMPLE): BOOL;
function BASS_SampleSetInfo(handle: HSAMPLE; var info: BASS_SAMPLE): BOOL;
function BASS_SampleGetChannel(handle: HSAMPLE; onlynew: BOOL): HCHANNEL;
function BASS_SampleGetChannels(handle: HSAMPLE; channels: Pointer): DWORD;
function BASS_SampleStop(handle: HSAMPLE): BOOL;

function BASS_StreamCreate(freq, chans, flags: DWORD; proc: STREAMPROC; user: Pointer): HSTREAM;
function BASS_StreamCreateFile(mem: BOOL; f: Pointer; offset, length: QWORD; flags: DWORD): HSTREAM;
function BASS_StreamCreateURL(url: PAnsiChar; offset: DWORD; flags: DWORD; proc: DOWNLOADPROC; user: Pointer):HSTREAM;
function BASS_StreamCreateFileUser(system, flags: DWORD; var procs: BASS_FILEPROCS; user: Pointer): HSTREAM;
function BASS_StreamFree(handle: HSTREAM): BOOL;
function BASS_StreamGetFilePosition(handle: HSTREAM; mode: DWORD): QWORD;
function BASS_StreamPutData(handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD;
function BASS_StreamPutFileData(handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD;

function BASS_RecordGetDeviceInfo(device: DWORD; var info: BASS_DEVICEINFO): BOOL;
function BASS_RecordInit(device: Integer):BOOL;
function BASS_RecordSetDevice(device: DWORD): BOOL;
function BASS_RecordGetDevice: DWORD;
function BASS_RecordFree: BOOL;
function BASS_RecordGetInfo(var info: BASS_RECORDINFO): BOOL;
function BASS_RecordGetInputName(input: Integer): PAnsiChar;
function BASS_RecordSetInput(input: Integer; flags: DWORD; volume: FLOAT): BOOL;
function BASS_RecordGetInput(input: Integer; var volume: FLOAT): DWORD;
function BASS_RecordStart(freq, chans, flags: DWORD; proc: RECORDPROC; user: Pointer): HRECORD;

function BASS_ChannelBytes2Seconds(handle: DWORD; pos: QWORD): Double;
function BASS_ChannelSeconds2Bytes(handle: DWORD; pos: Double): QWORD;
function BASS_ChannelGetDevice(handle: DWORD): DWORD;
function BASS_ChannelSetDevice(handle, device: DWORD): BOOL;
function BASS_ChannelIsActive(handle: DWORD): DWORD;
function BASS_ChannelGetInfo(handle: DWORD; var info: BASS_CHANNELINFO):BOOL;
function BASS_ChannelGetTags(handle: HSTREAM; tags: DWORD): PAnsiChar;
function BASS_ChannelFlags(handle, flags, mask: DWORD): DWORD;
function BASS_ChannelUpdate(handle, length: DWORD): BOOL;
function BASS_ChannelLock(handle: DWORD; lock: BOOL): BOOL;
function BASS_ChannelPlay(handle: DWORD; restart: BOOL): BOOL;
function BASS_ChannelStop(handle: DWORD): BOOL;
function BASS_ChannelPause(handle: DWORD): BOOL;
function BASS_ChannelSetAttribute(handle, attrib: DWORD; value: FLOAT): BOOL;
function BASS_ChannelGetAttribute(handle, attrib: DWORD; var value: FLOAT): BOOL;
function BASS_ChannelSlideAttribute(handle, attrib: DWORD; value: FLOAT; time: DWORD): BOOL;
function BASS_ChannelIsSliding(handle, attrib: DWORD): BOOL;
function BASS_ChannelSet3DAttributes(handle: DWORD; mode: Integer; min, max: FLOAT; iangle, oangle, outvol: Integer): BOOL;
function BASS_ChannelGet3DAttributes(handle: DWORD; var mode: DWORD; var min, max: FLOAT; var iangle, oangle, outvol: DWORD): BOOL;
function BASS_ChannelSet3DPosition(handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL;
function BASS_ChannelGet3DPosition(handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL;
function BASS_ChannelGetLength(handle, mode: DWORD): QWORD;
function BASS_ChannelSetPosition(handle: DWORD; pos: QWORD; mode: DWORD): BOOL;
function BASS_ChannelGetPosition(handle, mode: DWORD): QWORD;
function BASS_ChannelGetLevel(handle: DWORD): DWORD;
function BASS_ChannelGetData(handle: DWORD; buffer: Pointer; length: DWORD): DWORD;
function BASS_ChannelSetSync(handle: DWORD; type_: DWORD; param: QWORD; proc: SYNCPROC; user: Pointer): HSYNC;
function BASS_ChannelRemoveSync(handle: DWORD; sync: HSYNC): BOOL;
function BASS_ChannelSetDSP(handle: DWORD; proc: DSPPROC; user: Pointer; priority: Integer): HDSP;
function BASS_ChannelRemoveDSP(handle: DWORD; dsp: HDSP): BOOL;
function BASS_ChannelSetLink(handle, chan: DWORD): BOOL;
function BASS_ChannelRemoveLink(handle, chan: DWORD): BOOL;
function BASS_ChannelSetFX(handle, type_: DWORD; priority: Integer): HFX;
function BASS_ChannelRemoveFX(handle: DWORD; fx: HFX): BOOL;

function BASS_FXSetParameters(handle: HFX; par: Pointer): BOOL;
function BASS_FXGetParameters(handle: HFX; par: Pointer): BOOL;
function BASS_FXReset(handle: HFX): BOOL;


procedure BassLoadLib(Path: String);



var
  LibHandle : Cardinal;







implementation



(******************************************************************************)
procedure DllError(sCommand: String);
begin

  ShowMessage('Error in function: ' + sCommand +  #13 +
              'Error in library: bass.dll.')

end;

procedure BassLoadLib(Path: String);

begin

//showmessage(  Path + 'sqlite3.dll'  );

//showmessage(booltostr(FileExists( Path + 'sqlite3.dll')));
//  LibHandle := LoadLibrary( PAnsiChar(Path + 'bass.dll') );
  LibHandle := LoadLibrary( PWideChar(Path + 'bass.dll') );
  if LibHandle<>0 then
  begin
//    ShowMessage('ok.');
  end
  else
  begin
    ShowMessage('bass not loaded.');
  end;
end;

(******************************************************************************)




{$WARNINGS OFF}
function BASS_SetConfig(option, value: DWORD): BOOL;
var fSQL : TBASS_SetConfig;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SetConfig');

  if @fSQL <> nil then
    Result := fSQL(option, value)
  else
    DllError('BASS_SetConfig');
end;

function BASS_GetConfig(option: DWORD): DWORD;
var fSQL : TBASS_GetConfig;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetConfig');

  if @fSQL <> nil then
    Result := fSQL(option)
  else
    DllError('BASS_GetConfig');
end;

function BASS_SetConfigPtr(option: DWORD; value: Pointer): BOOL;
var fSQL : TBASS_SetConfigPtr;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SetConfigPtr');

  if @fSQL <> nil then
    Result := fSQL(option, value)
  else
    DllError('BASS_SetConfigPtr');
end;

function BASS_GetConfigPtr(option: DWORD): Pointer;
var fSQL : TBASS_GetConfigPtr;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetConfigPtr');

  if @fSQL <> nil then
    Result := fSQL(option)
  else
    DllError('BASS_GetConfigPtr');
end;

function BASS_GetVersion: DWORD;
var fSQL : TBASS_GetVersion;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetVersion');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_GetVersion');
end;

function BASS_ErrorGetCode: Integer;
var fSQL : TBASS_ErrorGetCode;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ErrorGetCode');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_ErrorGetCode');
end;

function BASS_GetDeviceInfo(device: DWORD; var info: BASS_DEVICEINFO): BOOL;
var fSQL : TBASS_GetDeviceInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetDeviceInfo');

  if @fSQL <> nil then
    Result := fSQL(device, info)
  else
    DllError('BASS_GetDeviceInfo');
end;

function BASS_Init(device: Integer; freq, flags: DWORD; win: HWND; clsid: PGUID): BOOL;
var fSQL : TBASS_Init;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Init');

  if @fSQL <> nil then
    Result := fSQL(device, freq, flags, win, clsid)
  else
    DllError('BASS_Init');
end;

function BASS_SetDevice(device: DWORD): BOOL;
var fSQL : TBASS_SetDevice;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SetDevice');

  if @fSQL <> nil then
    Result := fSQL(device)
  else
    DllError('BASS_SetDevice');
end;

function BASS_GetDevice: DWORD;
var fSQL : TBASS_GetDevice;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetDevice');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_GetDevice');
end;

function BASS_Free: BOOL;
var fSQL : TBASS_Free;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Free');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_Free');
end;

function BASS_GetDSoundObject(obj: DWORD): Pointer;
var fSQL : TBASS_GetDSoundObject;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetDSoundObject');

  if @fSQL <> nil then
    Result := fSQL(obj )
  else
    DllError('BASS_GetDSoundObject');
end;

function BASS_GetInfo(var info: BASS_INFO): BOOL;
var fSQL : TBASS_GetInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetInfo');

  if @fSQL <> nil then
    Result := fSQL(info)
  else
    DllError('BASS_GetInfo');
end;

function BASS_Update(length: DWORD): BOOL;
var fSQL : TBASS_Update;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Update');

  if @fSQL <> nil then
    Result := fSQL(length)
  else
    DllError('BASS_Update');
end;

function BASS_GetCPU: FLOAT;
var fSQL : TBASS_GetCPU;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetCPU');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_GetCPU');
end;

function BASS_Start: BOOL;
var fSQL : TBASS_Start;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Start');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_Start');
end;

function BASS_Stop: BOOL;
var fSQL : TBASS_Stop;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Stop');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_Stop');
end;

function BASS_Pause: BOOL;
var fSQL : TBASS_Pause;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Pause');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_Pause');
end;

function BASS_SetVolume(volume: FLOAT): BOOL;
var fSQL : TBASS_SetVolume;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SetVolume');

  if @fSQL <> nil then
    Result := fSQL(volume)
  else
    DllError('BASS_SetVolume');
end;

function BASS_GetVolume: FLOAT;
var fSQL : TBASS_GetVolume;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetVolume');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_GetVolume');
end;


function BASS_PluginLoad(filename: PAnsiChar; flags: DWORD): HPLUGIN;
var fSQL : TBASS_PluginLoad;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_PluginLoad');

  if @fSQL <> nil then
    Result := fSQL(filename, flags)
  else
    DllError('BASS_PluginLoad');
end;

function BASS_PluginFree(handle: HPLUGIN): BOOL;
var fSQL : TBASS_PluginFree;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_PluginFree');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_PluginFree');
end;

function BASS_PluginGetInfo(handle: HPLUGIN): PBASS_PLUGININFO;
var fSQL : TBASS_PluginGetInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_PluginGetInfo');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_PluginGetInfo');
end;


function BASS_Set3DFactors(distf, rollf, doppf: FLOAT): BOOL;
var fSQL : TBASS_Set3DFactors;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Set3DFactors');

  if @fSQL <> nil then
    Result := fSQL(distf, rollf, doppf)
  else
    DllError('BASS_Set3DFactors');
end;

function BASS_Get3DFactors(var distf, rollf, doppf: FLOAT): BOOL;
var fSQL : TBASS_Get3DFactors;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Get3DFactors');

  if @fSQL <> nil then
    Result := fSQL(distf, rollf, doppf)
  else
    DllError('BASS_Get3DFactors');
end;

function BASS_Set3DPosition(var pos, vel, front, top: BASS_3DVECTOR): BOOL;
var fSQL : TBASS_Set3DPosition;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Set3DPosition');

  if @fSQL <> nil then
    Result := fSQL(pos, vel, front, top)
  else
    DllError('BASS_Set3DPosition');
end;

function BASS_Get3DPosition(var pos, vel, front, top: BASS_3DVECTOR): BOOL;
var fSQL : TBASS_Get3DPosition;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Get3DPosition');

  if @fSQL <> nil then
    Result := fSQL(pos, vel, front, top)
  else
    DllError('BASS_Get3DPosition');
end;

procedure BASS_Apply3D;
var fSQL : TBASS_Apply3D;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_Apply3D');

  if @fSQL <> nil then
    fSQL( )
  else
    DllError('BASS_Apply3D');
end;

function BASS_SetEAXParameters(env: Integer; vol, decay, damp: FLOAT): BOOL;
var fSQL : TBASS_SetEAXParameters;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SetEAXParameters');

  if @fSQL <> nil then
    Result := fSQL(env, vol, decay, damp)
  else
    DllError('BASS_SetEAXParameters');
end;

function BASS_GetEAXParameters(var env: DWORD; var vol, decay, damp: FLOAT): BOOL;
var fSQL : TBASS_GetEAXParameters;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_GetEAXParameters');

  if @fSQL <> nil then
    Result := fSQL(env, vol, decay, damp)
  else
    DllError('BASS_GetEAXParameters');
end;


function BASS_MusicLoad(mem: BOOL; f: Pointer; offset: QWORD; length, flags, freq: DWORD): HMUSIC;
var fSQL : TBASS_MusicLoad;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_MusicLoad');

  if @fSQL <> nil then
    Result := fSQL(mem, f, offset, length, flags, freq)
  else
    DllError('BASS_MusicLoad');
end;

function BASS_MusicFree(handle: HMUSIC): BOOL;
var fSQL : TBASS_MusicFree;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_MusicFree');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_MusicFree');
end;


function BASS_SampleLoad(mem: BOOL; f: Pointer; offset: QWORD; length, max, flags: DWORD): HSAMPLE;
var fSQL : TBASS_SampleLoad;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleLoad');

  if @fSQL <> nil then
    Result := fSQL(mem, f, offset, length, max, flags)
  else
    DllError('BASS_SampleLoad');
end;

function BASS_SampleCreate(length, freq, chans, max, flags: DWORD): HSAMPLE;
var fSQL : TBASS_SampleCreate;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleCreate');

  if @fSQL <> nil then
    Result := fSQL(length, freq, chans, max, flags)
  else
    DllError('BASS_SampleCreate');
end;

function BASS_SampleFree(handle: HSAMPLE): BOOL;
var fSQL : TBASS_SampleFree;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleFree');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_SampleFree');
end;

function BASS_SampleSetData(handle: HSAMPLE; buffer: Pointer): BOOL;
var fSQL : TBASS_SampleSetData;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleSetData');

  if @fSQL <> nil then
    Result := fSQL(handle, buffer)
  else
    DllError('BASS_SampleSetData');
end;

function BASS_SampleGetData(handle: HSAMPLE; buffer: Pointer): BOOL;
var fSQL : TBASS_SampleGetData;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleGetData');

  if @fSQL <> nil then
    Result := fSQL(handle, buffer)
  else
    DllError('BASS_SampleGetData');
end;

function BASS_SampleGetInfo(handle: HSAMPLE; var info: BASS_SAMPLE): BOOL;
var fSQL : TBASS_SampleGetInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleGetInfo');

  if @fSQL <> nil then
    Result := fSQL(handle, info)
  else
    DllError('BASS_SampleGetInfo');
end;

function BASS_SampleSetInfo(handle: HSAMPLE; var info: BASS_SAMPLE): BOOL;
var fSQL : TBASS_SampleSetInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleSetInfo');

  if @fSQL <> nil then
    Result := fSQL(handle, info)
  else
    DllError('BASS_SampleSetInfo');
end;

function BASS_SampleGetChannel(handle: HSAMPLE; onlynew: BOOL): HCHANNEL;
var fSQL : TBASS_SampleGetChannel;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleGetChannel');

  if @fSQL <> nil then
    Result := fSQL(handle, onlynew)
  else
    DllError('BASS_SampleGetChannel');
end;

function BASS_SampleGetChannels(handle: HSAMPLE; channels: Pointer): DWORD;
var fSQL : TBASS_SampleGetChannels;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleGetChannels');

  if @fSQL <> nil then
    Result := fSQL(handle, channels)
  else
    DllError('BASS_SampleGetChannels');
end;

function BASS_SampleStop(handle: HSAMPLE): BOOL;
var fSQL : TBASS_SampleStop;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_SampleStop');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_SampleStop');
end;


function BASS_StreamCreate(freq, chans, flags: DWORD; proc: STREAMPROC; user: Pointer): HSTREAM;
var fSQL : TBASS_StreamCreate;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamCreate');

  if @fSQL <> nil then
    Result := fSQL(freq, chans, flags, proc, user)
  else
    DllError('BASS_StreamCreate');
end;

function BASS_StreamCreateFile(mem: BOOL; f: Pointer; offset, length: QWORD; flags: DWORD): HSTREAM;
var fSQL : TBASS_StreamCreateFile;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamCreateFile');

  if @fSQL <> nil then
    Result := fSQL(mem, f, offset, length, flags)
  else
    DllError('BASS_StreamCreateFile');
end;

function BASS_StreamCreateURL(url: PAnsiChar; offset: DWORD; flags: DWORD; proc: DOWNLOADPROC; user: Pointer):HSTREAM;
var fSQL : TBASS_StreamCreateURL;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamCreateURL');

  if @fSQL <> nil then
    Result := fSQL(url, offset, flags, proc, user)
  else
    DllError('BASS_StreamCreateURL');
end;

function BASS_StreamCreateFileUser(system, flags: DWORD; var procs: BASS_FILEPROCS; user: Pointer): HSTREAM;
var fSQL : TBASS_StreamCreateFileUser;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamCreateFileUser');

  if @fSQL <> nil then
    Result := fSQL(system, flags, procs, user)
  else
    DllError('BASS_StreamCreateFileUser');
end;

function BASS_StreamFree(handle: HSTREAM): BOOL;
var fSQL : TBASS_StreamFree;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamFree');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_StreamFree');
end;

function BASS_StreamGetFilePosition(handle: HSTREAM; mode: DWORD): QWORD;
var fSQL : TBASS_StreamGetFilePosition;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamGetFilePosition');

  if @fSQL <> nil then
    Result := fSQL(handle, mode)
  else
    DllError('BASS_StreamGetFilePosition');
end;

function BASS_StreamPutData(handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD;
var fSQL : TBASS_StreamPutData;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamPutData');

  if @fSQL <> nil then
    Result := fSQL(handle, buffer, length)
  else
    DllError('BASS_StreamPutData');
end;

function BASS_StreamPutFileData(handle: HSTREAM; buffer: Pointer; length: DWORD): DWORD;
var fSQL : TBASS_StreamPutFileData;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_StreamPutFileData');

  if @fSQL <> nil then
    Result := fSQL(handle, buffer, length)
  else
    DllError('BASS_StreamPutFileData');
end;


function BASS_RecordGetDeviceInfo(device: DWORD; var info: BASS_DEVICEINFO): BOOL;
var fSQL : TBASS_RecordGetDeviceInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordGetDeviceInfo');

  if @fSQL <> nil then
    Result := fSQL(device, info)
  else
    DllError('BASS_RecordGetDeviceInfo');
end;

function BASS_RecordInit(device: Integer):BOOL;
var fSQL : TBASS_RecordInit;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordInit');

  if @fSQL <> nil then
    Result := fSQL(device)
  else
    DllError('BASS_RecordInit');
end;

function BASS_RecordSetDevice(device: DWORD): BOOL;
var fSQL : TBASS_RecordSetDevice;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordSetDevice');

  if @fSQL <> nil then
    Result := fSQL(device)
  else
    DllError('BASS_RecordSetDevice');
end;

function BASS_RecordGetDevice: DWORD;
var fSQL : TBASS_RecordGetDevice;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordGetDevice');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_RecordGetDevice');
end;

function BASS_RecordFree: BOOL;
var fSQL : TBASS_RecordFree;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordFree');

  if @fSQL <> nil then
    Result := fSQL( )
  else
    DllError('BASS_RecordFree');
end;

function BASS_RecordGetInfo(var info: BASS_RECORDINFO): BOOL;
var fSQL : TBASS_RecordGetInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordGetInfo');

  if @fSQL <> nil then
    Result := fSQL(info)
  else
    DllError('BASS_RecordGetInfo');
end;

function BASS_RecordGetInputName(input: Integer): PAnsiChar;
var fSQL : TBASS_RecordGetInputName;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordGetInputName');

  if @fSQL <> nil then
    Result := fSQL(input)
  else
    DllError('BASS_RecordGetInputName');
end;

function BASS_RecordSetInput(input: Integer; flags: DWORD; volume: FLOAT): BOOL;
var fSQL : TBASS_RecordSetInput;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordSetInput');

  if @fSQL <> nil then
    Result := fSQL(input, flags, volume)
  else
    DllError('BASS_RecordSetInput');
end;

function BASS_RecordGetInput(input: Integer; var volume: FLOAT): DWORD;
var fSQL : TBASS_RecordGetInput;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordGetInput');

  if @fSQL <> nil then
    Result := fSQL(input, volume)
  else
    DllError('BASS_RecordGetInput');
end;

function BASS_RecordStart(freq, chans, flags: DWORD; proc: RECORDPROC; user: Pointer): HRECORD;
var fSQL : TBASS_RecordStart;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_RecordStart');

  if @fSQL <> nil then
    Result := fSQL(freq, chans, flags, proc, user)
  else
    DllError('BASS_RecordStart');
end;


function BASS_ChannelBytes2Seconds(handle: DWORD; pos: QWORD): Double;
var fSQL : TBASS_ChannelBytes2Seconds;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelBytes2Seconds');

  if @fSQL <> nil then
    Result := fSQL(handle, pos)
  else
    DllError('BASS_ChannelBytes2Seconds');
end;

function BASS_ChannelSeconds2Bytes(handle: DWORD; pos: Double): QWORD;
var fSQL : TBASS_ChannelSeconds2Bytes;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSeconds2Bytes');

  if @fSQL <> nil then
    Result := fSQL(handle, pos)
  else
    DllError('BASS_ChannelSeconds2Bytes');
end;

function BASS_ChannelGetDevice(handle: DWORD): DWORD;
var fSQL : TBASS_ChannelGetDevice;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetDevice');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_ChannelGetDevice');
end;

function BASS_ChannelSetDevice(handle, device: DWORD): BOOL;
var fSQL : TBASS_ChannelSetDevice;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSetDevice');

  if @fSQL <> nil then
    Result := fSQL(handle, device)
  else
    DllError('BASS_ChannelSetDevice');
end;

function BASS_ChannelIsActive(handle: DWORD): DWORD;
var fSQL : TBASS_ChannelIsActive;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelIsActive');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_ChannelIsActive');
end;

function BASS_ChannelGetInfo(handle: DWORD; var info: BASS_CHANNELINFO):BOOL;
var fSQL : TBASS_ChannelGetInfo;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetInfo');

  if @fSQL <> nil then
    Result := fSQL(handle, info)
  else
    DllError('BASS_ChannelGetInfo');
end;

function BASS_ChannelGetTags(handle: HSTREAM; tags: DWORD): PAnsiChar;
var fSQL : TBASS_ChannelGetTags;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetTags');

  if @fSQL <> nil then
    Result := fSQL(handle, tags)
  else
    DllError('BASS_ChannelGetTags');
end;

function BASS_ChannelFlags(handle, flags, mask: DWORD): DWORD;
var fSQL : TBASS_ChannelFlags;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelFlags');

  if @fSQL <> nil then
    Result := fSQL(handle, flags, mask)
  else
    DllError('BASS_ChannelFlags');
end;

function BASS_ChannelUpdate(handle, length: DWORD): BOOL;
var fSQL : TBASS_ChannelUpdate;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelUpdate');

  if @fSQL <> nil then
    Result := fSQL(handle, length)
  else
    DllError('BASS_ChannelUpdate');
end;

function BASS_ChannelLock(handle: DWORD; lock: BOOL): BOOL;
var fSQL : TBASS_ChannelLock;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelLock');

  if @fSQL <> nil then
    Result := fSQL(handle, lock)
  else
    DllError('BASS_ChannelLock');
end;

function BASS_ChannelPlay(handle: DWORD; restart: BOOL): BOOL;
var fSQL : TBASS_ChannelPlay;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelPlay');

  if @fSQL <> nil then
    Result := fSQL(handle, restart)
  else
    DllError('BASS_ChannelPlay');
end;

function BASS_ChannelStop(handle: DWORD): BOOL;
var fSQL : TBASS_ChannelStop;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelStop');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_ChannelStop');
end;

function BASS_ChannelPause(handle: DWORD): BOOL;
var fSQL : TBASS_ChannelPause;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelPause');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_ChannelPause');
end;

function BASS_ChannelSetAttribute(handle, attrib: DWORD; value: FLOAT): BOOL;
var fSQL : TBASS_ChannelSetAttribute;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSetAttribute');

  if @fSQL <> nil then
    Result := fSQL(handle, attrib, value)
  else
    DllError('BASS_ChannelSetAttribute');
end;

function BASS_ChannelGetAttribute(handle, attrib: DWORD; var value: FLOAT): BOOL;
var fSQL : TBASS_ChannelGetAttribute;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetAttribute');

  if @fSQL <> nil then
    Result := fSQL(handle, attrib, value)
  else
    DllError('BASS_ChannelGetAttribute');
end;

function BASS_ChannelSlideAttribute(handle, attrib: DWORD; value: FLOAT; time: DWORD): BOOL;
var fSQL : TBASS_ChannelSlideAttribute;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSlideAttribute');

  if @fSQL <> nil then
    Result := fSQL(handle, attrib, value, time)
  else
    DllError('BASS_ChannelSlideAttribute');
end;

function BASS_ChannelIsSliding(handle, attrib: DWORD): BOOL;
var fSQL : TBASS_ChannelIsSliding;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelIsSliding');

  if @fSQL <> nil then
    Result := fSQL(handle, attrib)
  else
    DllError('BASS_ChannelIsSliding');
end;

function BASS_ChannelSet3DAttributes(handle: DWORD; mode: Integer; min, max: FLOAT; iangle, oangle, outvol: Integer): BOOL;
var fSQL : TBASS_ChannelSet3DAttributes;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSet3DAttributes');

  if @fSQL <> nil then
    Result := fSQL(handle, mode, min, max, iangle, oangle, outvol)
  else
    DllError('BASS_ChannelSet3DAttributes');
end;

function BASS_ChannelGet3DAttributes(handle: DWORD; var mode: DWORD; var min, max: FLOAT; var iangle, oangle, outvol: DWORD): BOOL;
var fSQL : TBASS_ChannelGet3DAttributes;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGet3DAttributes');

  if @fSQL <> nil then
    Result := fSQL(handle, mode, min, max, iangle, oangle, outvol)
  else
    DllError('BASS_ChannelGet3DAttributes');
end;

function BASS_ChannelSet3DPosition(handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL;
var fSQL : TBASS_ChannelSet3DPosition;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSet3DPosition');

  if @fSQL <> nil then
    Result := fSQL(handle, pos, orient, vel)
  else
    DllError('BASS_ChannelSet3DPosition');
end;

function BASS_ChannelGet3DPosition(handle: DWORD; var pos, orient, vel: BASS_3DVECTOR): BOOL;
var fSQL : TBASS_ChannelGet3DPosition;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGet3DPosition');

  if @fSQL <> nil then
    Result := fSQL(handle, pos, orient, vel)
  else
    DllError('BASS_ChannelGet3DPosition');
end;

function BASS_ChannelGetLength(handle, mode: DWORD): QWORD;
var fSQL : TBASS_ChannelGetLength;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetLength');

  if @fSQL <> nil then
    Result := fSQL(handle, mode)
  else
    DllError('BASS_ChannelGetLength');
end;

function BASS_ChannelSetPosition(handle: DWORD; pos: QWORD; mode: DWORD): BOOL;
var fSQL : TBASS_ChannelSetPosition;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSetPosition');

  if @fSQL <> nil then
    Result := fSQL(handle, pos, mode)
  else
    DllError('BASS_ChannelSetPosition');
end;

function BASS_ChannelGetPosition(handle, mode: DWORD): QWORD;
var fSQL : TBASS_ChannelGetPosition;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetPosition');

  if @fSQL <> nil then
    Result := fSQL(handle, mode)
  else
    DllError('BASS_ChannelGetPosition');
end;

function BASS_ChannelGetLevel(handle: DWORD): DWORD;
var fSQL : TBASS_ChannelGetLevel;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetLevel');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_ChannelGetLevel');
end;

function BASS_ChannelGetData(handle: DWORD; buffer: Pointer; length: DWORD): DWORD;
var fSQL : TBASS_ChannelGetData;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelGetData');

  if @fSQL <> nil then
    Result := fSQL(handle, buffer, length)
  else
    DllError('BASS_ChannelGetData');
end;

function BASS_ChannelSetSync(handle: DWORD; type_: DWORD; param: QWORD; proc: SYNCPROC; user: Pointer): HSYNC;
var fSQL : TBASS_ChannelSetSync;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSetSync');

  if @fSQL <> nil then
    Result := fSQL(handle, type_, param, proc, user)
  else
    DllError('BASS_ChannelSetSync');
end;

function BASS_ChannelRemoveSync(handle: DWORD; sync: HSYNC): BOOL;
var fSQL : TBASS_ChannelRemoveSync;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelRemoveSync');

  if @fSQL <> nil then
    Result := fSQL(handle, sync)
  else
    DllError('BASS_ChannelRemoveSync');
end;

function BASS_ChannelSetDSP(handle: DWORD; proc: DSPPROC; user: Pointer; priority: Integer): HDSP;
var fSQL : TBASS_ChannelSetDSP;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSetDSP');

  if @fSQL <> nil then
    Result := fSQL(handle, proc, user, priority)
  else
    DllError('BASS_ChannelSetDSP');
end;

function BASS_ChannelRemoveDSP(handle: DWORD; dsp: HDSP): BOOL;
var fSQL : TBASS_ChannelRemoveDSP;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelRemoveDSP');

  if @fSQL <> nil then
    Result := fSQL(handle, dsp)
  else
    DllError('BASS_ChannelRemoveDSP');
end;

function BASS_ChannelSetLink(handle, chan: DWORD): BOOL;
var fSQL : TBASS_ChannelSetLink;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSetLink');

  if @fSQL <> nil then
    Result := fSQL(handle, chan)
  else
    DllError('BASS_ChannelSetLink');
end;

function BASS_ChannelRemoveLink(handle, chan: DWORD): BOOL;
var fSQL : TBASS_ChannelRemoveLink;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelRemoveLink');

  if @fSQL <> nil then
    Result := fSQL(handle, chan)
  else
    DllError('BASS_ChannelRemoveLink');
end;

function BASS_ChannelSetFX(handle, type_: DWORD; priority: Integer): HFX;
var fSQL : TBASS_ChannelSetFX;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelSetFX');

  if @fSQL <> nil then
    Result := fSQL(handle, type_, priority)
  else
    DllError('BASS_ChannelSetFX');
end;

function BASS_ChannelRemoveFX(handle: DWORD; fx: HFX): BOOL;
var fSQL : TBASS_ChannelRemoveFX;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_ChannelRemoveFX');

  if @fSQL <> nil then
    Result := fSQL(handle, fx)
  else
    DllError('BASS_ChannelRemoveFX');
end;


function BASS_FXSetParameters(handle: HFX; par: Pointer): BOOL;
var fSQL : TBASS_FXSetParameters;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_FXSetParameters');

  if @fSQL <> nil then
    Result := fSQL(handle, par)
  else
    DllError('BASS_FXSetParameters');
end;

function BASS_FXGetParameters(handle: HFX; par: Pointer): BOOL;
var fSQL : TBASS_FXGetParameters;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_FXGetParameters');

  if @fSQL <> nil then
    Result := fSQL(handle, par)
  else
    DllError('BASS_FXGetParameters');
end;

function BASS_FXReset(handle: HFX): BOOL;
var fSQL : TBASS_FXReset;
begin
  @fSQL := nil;
  @fSQL := GetProcAddress(LibHandle, 'BASS_FXReset');

  if @fSQL <> nil then
    Result := fSQL(handle)
  else
    DllError('BASS_FXReset');
end;
{$WARNINGS ON}







(******************************************************************************)





function BASS_SPEAKER_N(n: DWORD): DWORD;
begin
  Result := n shl 24;
end;

function BASS_SetEAXPreset(env: Integer): BOOL;
begin
  case (env) of
    EAX_ENVIRONMENT_GENERIC:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_GENERIC, 0.5, 1.493, 0.5);
    EAX_ENVIRONMENT_PADDEDCELL:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_PADDEDCELL, 0.25, 0.1, 0);
    EAX_ENVIRONMENT_ROOM:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_ROOM, 0.417, 0.4, 0.666);
    EAX_ENVIRONMENT_BATHROOM:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_BATHROOM, 0.653, 1.499, 0.166);
    EAX_ENVIRONMENT_LIVINGROOM:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_LIVINGROOM, 0.208, 0.478, 0);
    EAX_ENVIRONMENT_STONEROOM:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_STONEROOM, 0.5, 2.309, 0.888);
    EAX_ENVIRONMENT_AUDITORIUM:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_AUDITORIUM, 0.403, 4.279, 0.5);
    EAX_ENVIRONMENT_CONCERTHALL:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_CONCERTHALL, 0.5, 3.961, 0.5);
    EAX_ENVIRONMENT_CAVE:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_CAVE, 0.5, 2.886, 1.304);
    EAX_ENVIRONMENT_ARENA:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_ARENA, 0.361, 7.284, 0.332);
    EAX_ENVIRONMENT_HANGAR:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_HANGAR, 0.5, 10.0, 0.3);
    EAX_ENVIRONMENT_CARPETEDHALLWAY:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_CARPETEDHALLWAY, 0.153, 0.259, 2.0);
    EAX_ENVIRONMENT_HALLWAY:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_HALLWAY, 0.361, 1.493, 0);
    EAX_ENVIRONMENT_STONECORRIDOR:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_STONECORRIDOR, 0.444, 2.697, 0.638);
    EAX_ENVIRONMENT_ALLEY:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_ALLEY, 0.25, 1.752, 0.776);
    EAX_ENVIRONMENT_FOREST:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_FOREST, 0.111, 3.145, 0.472);
    EAX_ENVIRONMENT_CITY:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_CITY, 0.111, 2.767, 0.224);
    EAX_ENVIRONMENT_MOUNTAINS:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_MOUNTAINS, 0.194, 7.841, 0.472);
    EAX_ENVIRONMENT_QUARRY:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_QUARRY, 1, 1.499, 0.5);
    EAX_ENVIRONMENT_PLAIN:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_PLAIN, 0.097, 2.767, 0.224);
    EAX_ENVIRONMENT_PARKINGLOT:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_PARKINGLOT, 0.208, 1.652, 1.5);
    EAX_ENVIRONMENT_SEWERPIPE:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_SEWERPIPE, 0.652, 2.886, 0.25);
    EAX_ENVIRONMENT_UNDERWATER:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_UNDERWATER, 1, 1.499, 0);
    EAX_ENVIRONMENT_DRUGGED:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_DRUGGED, 0.875, 8.392, 1.388);
    EAX_ENVIRONMENT_DIZZY:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_DIZZY, 0.139, 17.234, 0.666);
    EAX_ENVIRONMENT_PSYCHOTIC:
      Result := BASS_SetEAXParameters(EAX_ENVIRONMENT_PSYCHOTIC, 0.486, 7.563, 0.806);
    else
      Result := FALSE;
  end;
end;

end.
// END OF FILE /////////////////////////////////////////////////////////////////

